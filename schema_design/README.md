# Проектное задание: SQL

Результатом вашей работы в этом спринте должен стать DDL-файл с описанием базы данных. Заполнять базу или описывать в репозитории скрипты для её заполнения не нужно.

Критерии готовности:

- В репозитории есть DDL-файл с перечнем SQL-запросов, необходимых для создания базы с нуля.
- Таблицы и названия полей соответствуют схеме из первого урока.
- Созданы индексы и ограничения уникальности.
- Все таблицы находятся в схеме content.
- В качестве первичных ключей используется uuid.

---

# Конспект

### Иерархия элементов реляционной БД
    БД-->схема-->сущность-->атрибут

### Модели реляционной БД

|название|определение|пример|
|---|---|---|
|концептуальный|словесное описание моделируемых процессов и их взаимосвязей|Основную информацию о фильме можно уместить в три сущности:<br>1. Filmwork (Основная информация о кинопроизведении: название, описание, дата создания, рейтинг и тип — фильм, сериал, мультфильм или что-то ещё)<br> 2.Genre (жанр — драма, боевик, ужасы, мелодрама)<br> 3.Person (участник фильма — актёр, продюсер или режиссёр).<br> Одно произведение может быть нескольких жанров, и наверняка в его создании участвовало несколько персон. Поэтому между этими таблицами стоит использовать связь «многие ко многим».|
|логический|оптимизированный и нормализованный набор атрибутов, характеризующих данные, а также связанные с данными методы их обработки|1. filmwork:id,title,description,creation_date,file_path,rating,type,created_at,updated_at<br> 2. genre:id,name,description,created_at,updated_at<br> 3. person:id,full_name,created_at,updated_at<br> 4. filmworkgenre:id,filmwork_id,genre_id,created_at<br> 5. filmworkperson:id,filmwork_id,person_id,role,created_at|
|физический|программное воплощение структур данных|1. docker run -d --name postgres<br>-p 5432:5432<br>-v ${pwd}/postgresql/data:/var/lib/postgresql/data<br>-e POSTGRES_PASSWORD=123qwe<br>-e POSTGRES_USER=app<br>-e POSTGRES_DB=movies_database<br>postgres:13<br>2. psql -h 127.0.0.1 -U app -d movies_database -f [movies_database.ddl](movies_database.ddl) |
|данные|модель реальности, выраженная в символьно-числовом виде|миграция БД из sqlite3 в postgre|

### Оптимизация запросов

Просмотреть план запроса можно с помощью команды ```EXPLAIN ANALYZE```

Пример:
```
EXPLAIN ANALYZE SELECT * FROM content.film_work WHERE creation_date = '2020-04-01';
-------------------------------------------
Gather  (cost=1000.00..17461.78 rows=24 width=156) (actual time=32.744..35.865 rows=24 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   ->  Parallel Seq Scan on film_work  (cost=0.00..16459.38 rows=10 width=156) (actual time=29.025..29.191 rows=8 loops=3)
         Filter: (creation_date = '2020-04-01'::date)
         Rows Removed by Filter: 353552
 Planning time: 0.161 ms
 Execution time: 36.109 ms
(8 rows)
```

Основные моменты:
* Gather — этап конкатенации данных из двух процессов, которые выполняли параллельное сканирование таблицы.
    rows=24 — в результате операции было найдено всего 24 записи.
* Workers planned: 2 — планируется использовать два процесса для выполнения запроса.
* Workers Launched: 2 — БД использовала два процесса для обработки запроса.
* Parallel Seq Scan — таблица film_work была полностью просканирована.
* Filter — условие, для которого был составлен план.
* Rows Removed by Filter — сколько строк было отфильтровано каждым процессом.
* Planning time — время, затраченное на построение плана запроса.
* Execution time — время в миллисекундах, за которое выполнился запрос.

**Индекс** - стркутра данных.<br>
"+" ускоряют выброку<br>
"-" замедляют вставку<br>
"-" занимают место на диске<br>
По умолчанию используется _B-tree_ индекс, который позволит искать данные за ```O(log n)```

создание индекса:<br>
```CREATE INDEX film_work_creation_date_idx ON content.film_work(creation_date);```

* film_work_creation_date_idx — название индекса.
* ON content.film_work — таблица, для которой создаётся индекс.
* (creation_date) — в скобках указана колонка, по которой создаётся индекс.

Индекс может быть простым, составным (+ уникальным)

Дополнительные материалы:
* [Документация EXPLAIN](https://postgrespro.ru/docs/postgresql/12/using-explain)<br>
* [Конспект про индексы](https://use-the-index-luke.com/)


